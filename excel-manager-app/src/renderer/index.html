<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excel æ•°æ®ç®¡ç†å™¨</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles/main.css">
    <style>
        /* å†…åµŒå…³é”®æ ·å¼ä»¥é˜²å¤–éƒ¨CSSåŠ è½½å¤±è´¥ */
        .status { padding: 12px; margin: 15px 0; border-radius: 6px; display: none; font-weight: 500; line-height: 1.5; }
        .status.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .status.info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .button:disabled { background: #ccc !important; cursor: not-allowed; }
        
        /* å¤šé€‰åˆ—é€‰æ‹©å™¨æ ·å¼ */
        .column-selector { margin-bottom: 15px; display: none; }
        .column-selector h3 { margin-bottom: 15px; color: #333; }
        .column-section { margin-bottom: 20px; padding: 15px; border-radius: 8px; }
        .recommended-section { background: #e8f5e8; border: 1px solid #4CAF50; }
        .all-columns-section { background: #f9f9f9; border: 1px solid #ddd; }
        .control-buttons { margin-bottom: 15px; display: flex; gap: 10px; align-items: center; }
        .checkbox-container { display: flex; align-items: center; gap: 8px; padding: 6px; border-radius: 4px; transition: background-color 0.2s; margin-bottom: 8px; }
        .checkbox-container:hover { background-color: #f0f0f0; }
        .checkbox-container input[type="checkbox"] { width: 16px; height: 16px; }
        .checkbox-container label { cursor: pointer; flex: 1; font-size: 14px; line-height: 1.4; }
        .category-group { margin-bottom: 15px; }
        .category-label { font-weight: bold; color: #555; margin-bottom: 8px; font-size: 14px; }
        .columns-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 8px; margin-left: 15px; }
        
        /* è¡¨æ ¼å®¹å™¨æ ·å¼ */
        .table-container {
            overflow-x: auto;
            margin-top: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        /* ä¿®å¤è¡¨æ ¼æ ·å¼ */
        .table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            min-width: 600px;
        }
        
        .table th,
        .table td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: left;
            font-size: 14px;
        }
        
        .table th {
            background: #4CAF50;
            color: white;
            font-weight: bold;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .table tr:nth-child(even) {
            background: #f9f9f9;
        }
        
        .table tr:hover {
            background: #e8f5e8;
        }
        
        .table td {
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“Š Excel æ•°æ®ç®¡ç†å™¨</h1>
            <p>æ™ºèƒ½ç­›é€‰ Â· é«˜æ•ˆå¯¼å‡º Â· æ•°æ®é‡ç»„</p>
        </div>

        <div class="content">
            <!-- æ–‡ä»¶ä¸Šä¼ åŒºåŸŸ -->
            <div class="section">
                <h2>ğŸ“ ç¬¬ä¸€æ­¥ï¼šä¸Šä¼ Excelæ–‡ä»¶</h2>
                <input type="file" id="fileInput" class="file-input" accept=".xlsx,.xls,.csv" />
                <div class="help-text">æ”¯æŒ .xlsxã€.xlsã€.csv æ ¼å¼æ–‡ä»¶ï¼Œæ‹–æ‹½æ–‡ä»¶åˆ°æ­¤åŒºåŸŸä¹Ÿå¯ä¸Šä¼ </div>
                <div id="fileStatus" class="status"></div>
                
                <!-- æ–‡ä»¶ä¿¡æ¯æ˜¾ç¤º -->
                <div id="fileInfo" class="file-info" style="display: none;">
                    <strong>ğŸ“„ æ–‡ä»¶ä¿¡æ¯</strong>
                    <div id="fileDetails"></div>
                </div>
                
                <!-- æ•°æ®ç»Ÿè®¡æ˜¾ç¤º -->
                <div id="dataStats" class="data-stats" style="display: none;">
                    <strong>ğŸ“ˆ æ•°æ®æ¦‚è§ˆ</strong>
                    <div class="stats-grid">
                        <div class="stat-item">
                            <div id="totalRows" class="stat-number">0</div>
                            <div class="stat-label">æ€»è¡Œæ•°</div>
                        </div>
                        <div class="stat-item">
                            <div id="totalColumns" class="stat-number">0</div>
                            <div class="stat-label">æ€»åˆ—æ•°</div>
                        </div>
                        <div class="stat-item">
                            <div id="cityColumn" class="stat-number">-</div>
                            <div class="stat-label">ç­›é€‰åˆ—</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- æ•°æ®ç­›é€‰ç»„ä»¶ -->
            <div class="section">
                <h2>ğŸ” ç¬¬äºŒæ­¥ï¼šé€‰æ‹©ç­›é€‰åˆ—å¹¶ç­›é€‰æ•°æ®</h2>
                
                <!-- å¤šé€‰åˆ—é€‰æ‹©å™¨ -->
                <div id="columnSelector" class="column-selector">
                    <!-- åŠ¨æ€ç”Ÿæˆçš„å†…å®¹ä¼šæ’å…¥è¿™é‡Œ -->
                </div>
                
                <!-- åŒ¹é…æ¨¡å¼é€‰æ‹© -->
                <div style="margin-bottom: 15px; padding: 10px; background: #f0f8ff; border-radius: 6px; border: 1px solid #e0e8f0;">
                    <label style="font-weight: bold; color: #333; margin-bottom: 8px; display: block;">ğŸ¯ åŒ¹é…æ¨¡å¼ï¼š</label>
                    <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                        <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                            <input type="radio" name="matchMode" value="exact" checked>
                            <span>ç²¾ç¡®åŒ¹é…ï¼ˆå®Œå…¨ç›¸ç­‰ï¼‰</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                            <input type="radio" name="matchMode" value="exactIgnoreCase">
                            <span>ç²¾ç¡®åŒ¹é…ï¼ˆå¿½ç•¥å¤§å°å†™ï¼‰</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                            <input type="radio" name="matchMode" value="contains">
                            <span>åŒ…å«åŒ¹é…ï¼ˆå¹¿ä¹‰æœç´¢ï¼‰</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                            <input type="radio" name="matchMode" value="containsIgnoreCase">
                            <span>åŒ…å«åŒ¹é…ï¼ˆå¿½ç•¥å¤§å°å†™ï¼‰</span>
                        </label>
                    </div>
                </div>
                
                <!-- å¤šé¡¹æœç´¢é€‰é¡¹ -->
                <div style="margin-top: 8px;">
                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                        <input type="checkbox" id="multiSearch" checked>
                        <span style="font-weight: bold; color: #4CAF50;">ğŸ” å¤šé¡¹æœç´¢ï¼ˆç”¨é€—å·åˆ†éš”å¤šä¸ªæœç´¢è¯ï¼‰</span>
                    </label>
                    
                    <!-- é€»è¾‘æ¨¡å¼é€‰æ‹©å™¨ - åµŒå¥—åœ¨å¤šé¡¹æœç´¢ä¸‹é¢ -->
                    <div id="logicModeSelector" style="margin-top: 8px; margin-left: 25px; padding: 8px; background: #f8f9fa; border-radius: 4px; border: 1px solid #e9ecef; display: block;">
                        <label style="font-weight: bold; color: #333; margin-bottom: 5px; display: block;">ğŸ”— å¤šé¡¹æœç´¢é€»è¾‘ï¼š</label>
                        <div style="display: flex; gap: 15px;">
                            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                                <input type="radio" name="logicMode" value="or" checked>
                                <span>ORæ¨¡å¼ï¼ˆä»»ä¸€æ¡ä»¶æ»¡è¶³ï¼‰</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                                <input type="radio" name="logicMode" value="and">
                                <span>ANDæ¨¡å¼ï¼ˆæ‰€æœ‰æ¡ä»¶éƒ½è¦æ»¡è¶³ï¼‰</span>
                            </label>
                        </div>
                        <p style="font-size: 11px; color: #666; margin: 5px 0 0 0;">
                            ğŸ’¡ ORæ¨¡å¼ï¼šæœç´¢"åŒ—äº¬,ä¸Šæµ·"æ—¶ï¼ŒåŒ…å«åŒ—äº¬æˆ–ä¸Šæµ·çš„æ•°æ®éƒ½ä¼šæ˜¾ç¤º<br>
                            ğŸ’¡ ANDæ¨¡å¼ï¼šæœç´¢"åŒ—äº¬,2023"æ—¶ï¼ŒåŒæ—¶åŒ…å«åŒ—äº¬å’Œ2023çš„æ•°æ®æ‰ä¼šæ˜¾ç¤º
                        </p>
                    </div>
                </div>
                
                <p style="font-size: 12px; color: #666; margin-top: 5px; margin-bottom: 0;">
                    ğŸ’¡ <strong>ä½¿ç”¨è¯´æ˜ï¼š</strong><br>
                    â€¢ ç²¾ç¡®åŒ¹é…ï¼šè¾“å…¥å€¼å¿…é¡»ä¸æ•°æ®å®Œå…¨ä¸€è‡´<br>
                    â€¢ åŒ…å«åŒ¹é…ï¼šæ•°æ®ä¸­åŒ…å«è¾“å…¥å€¼å³å¯åŒ¹é…<br>
                    â€¢ å¤šé¡¹æœç´¢ï¼šç”¨é€—å·åˆ†éš”ï¼Œæ”¯æŒä¸­è‹±æ–‡é€—å·ï¼Œå¦‚"åŒ—äº¬,ä¸Šæµ·,å¹¿å·"æˆ–"åŒ—äº¬ï¼Œä¸Šæµ·ï¼Œå¹¿å·"<br><br>
                </p>
                
                <!-- æœç´¢è¾“å…¥æ¡† -->
                <input type="text" id="cityInput" class="text-input" placeholder="è¾“å…¥æœç´¢è¯ï¼Œå¤šä¸ªè¯ç”¨é€—å·åˆ†éš”ï¼ˆæ”¯æŒä¸­è‹±æ–‡é€—å·ï¼‰ï¼Œå¦‚ï¼šåŒ—äº¬,ä¸Šæµ·,å¹¿å· æˆ– åŒ—äº¬ï¼Œä¸Šæµ·ï¼Œå¹¿å·" disabled />
                <div class="help-text">æ”¯æŒå¤šä¸ªæœç´¢è¯ï¼ˆç”¨é€—å·åˆ†éš”ï¼‰ï¼Œå¦‚ï¼šåŒ—äº¬,ä¸Šæµ·,æ·±åœ³</div>
                
                <!-- æ“ä½œæŒ‰é’® -->
                <div style="margin-top: 1rem; display: flex; gap: 0.75rem; flex-wrap: wrap;">
                    <button id="filterBtn" class="button" disabled>ğŸ” æ™ºèƒ½ç­›é€‰</button>
                    <button id="clearFilterBtn" class="button secondary" disabled>ğŸ—‘ï¸ æ¸…é™¤ç­›é€‰</button>
                </div>
                <div id="filterStatus" class="status"></div>
            </div>

            <!-- æ•°æ®å¯¼å‡º -->
            <div class="section">
                <h2>ğŸ’¾ ç¬¬ä¸‰æ­¥ï¼šå¯¼å‡ºç­›é€‰ç»“æœ</h2>
                <div class="export-options">
                    <input type="text" id="filenameInput" class="filename-input" placeholder="è¾“å…¥æ–‡ä»¶åï¼ˆä¸å«æ‰©å±•åï¼‰" value="ç­›é€‰ç»“æœ" />
                    <button id="exportCSVBtn" class="button success" disabled>ğŸ’¾ å¯¼å‡º CSV</button>
                    <button id="exportExcelBtn" class="button secondary" disabled>ğŸ“Š å¯¼å‡º Excelå…¼å®¹</button>
                </div>
                <div id="exportStatus" class="status"></div>
            </div>
            
            <!-- æ•°æ®é¢„è§ˆ -->
            <div id="results" class="results" style="display: none;">
                <h3 style="color: var(--neutral-900); margin-bottom: 1rem; font-size: 1.125rem; font-weight: 600;">ğŸ“‹ æ•°æ®é¢„è§ˆ</h3>
                <div id="dataPreview"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    
    <!-- å®Œæ•´åŠŸèƒ½å®ç° -->
    <script>
    console.log('ğŸš€ å¼€å§‹åŠ è½½å®Œæ•´åŠŸèƒ½...');

    // æ£€æŸ¥XLSXåº“
    if (typeof XLSX === 'undefined') {
        alert('XLSXåº“åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
    }

    // Excelç®¡ç†å™¨ç±»
    class ExcelManager {
        constructor() {
            this.excelData = [];
            this.filteredData = [];
            this.selectedColumns = [];
            this.availableColumns = [];
            
            this.init();
        }

        init() {
            console.log('ğŸš€ åˆå§‹åŒ–Excelç®¡ç†å™¨...');
            
            // å¤šé¡¹æœç´¢å¤é€‰æ¡†äº‹ä»¶
            const multiSearchCheckbox = document.getElementById('multiSearch');
            const logicModeSelector = document.getElementById('logicModeSelector');
            
            if (multiSearchCheckbox && logicModeSelector) {
                // åˆå§‹åŒ–æ˜¾ç¤ºçŠ¶æ€
                const updateLogicModeVisibility = () => {
                    logicModeSelector.style.display = multiSearchCheckbox.checked ? 'block' : 'none';
                };
                
                // è®¾ç½®åˆå§‹çŠ¶æ€
                updateLogicModeVisibility();
                
                // ç›‘å¬å¤šé¡¹æœç´¢å¤é€‰æ¡†å˜åŒ–
                multiSearchCheckbox.addEventListener('change', updateLogicModeVisibility);
                
                console.log('âœ… å¤šé¡¹æœç´¢å’Œé€»è¾‘æ¨¡å¼é€‰æ‹©å™¨äº‹ä»¶ç»‘å®šæˆåŠŸ');
            }
            
            this.bindEvents();
        }

        bindEvents() {
            // æ–‡ä»¶ä¸Šä¼ äº‹ä»¶
            const fileInput = document.getElementById('fileInput');
            if (fileInput) {
                fileInput.addEventListener('change', (e) => {
                    console.log('ğŸ“ æ–‡ä»¶changeäº‹ä»¶è§¦å‘');
                    this.handleFileUpload(e);
                });
                console.log('âœ… æ–‡ä»¶ä¸Šä¼ äº‹ä»¶ç»‘å®šæˆåŠŸ');
            }

            // ç­›é€‰æŒ‰é’®
            const filterBtn = document.getElementById('filterBtn');
            if (filterBtn) {
                filterBtn.addEventListener('click', () => this.handleFilter());
            }

            // æ¸…é™¤ç­›é€‰æŒ‰é’®
            const clearFilterBtn = document.getElementById('clearFilterBtn');
            if (clearFilterBtn) {
                clearFilterBtn.addEventListener('click', () => this.clearFilter());
            }

            // å¯¼å‡ºæŒ‰é’®
            const exportCSVBtn = document.getElementById('exportCSVBtn');
            if (exportCSVBtn) {
                exportCSVBtn.addEventListener('click', () => this.exportCSV());
            }

            const exportExcelBtn = document.getElementById('exportExcelBtn');
            if (exportExcelBtn) {
                exportExcelBtn.addEventListener('click', () => this.exportExcel());
            }
        }

        async handleFileUpload(event) {
            console.log('ğŸ¯ å¤„ç†æ–‡ä»¶ä¸Šä¼ ...');
            
            const file = event.target.files[0];
            if (!file) {
                console.log('âŒ æ²¡æœ‰é€‰æ‹©æ–‡ä»¶');
                return;
            }

            console.log('ğŸ“ æ–‡ä»¶ä¿¡æ¯:', file.name, file.size, file.type);

            // æ˜¾ç¤ºå¤„ç†çŠ¶æ€
            this.showStatus('fileStatus', 'ğŸ“‹ æ­£åœ¨å¤„ç†æ–‡ä»¶...', 'info');

            // é‡ç½®æ•°æ®
            this.excelData = [];
            this.filteredData = [];
            this.selectedColumns = [];
            this.availableColumns = [];

            try {
                const fileName = file.name.toLowerCase();
                
                if (fileName.endsWith('.csv')) {
                    console.log('ğŸ“„ å¤„ç†CSVæ–‡ä»¶');
                    await this.handleCSVFile(file);
                } else if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) {
                    console.log('ğŸ“Š å¤„ç†Excelæ–‡ä»¶');
                    await this.handleExcelFile(file);
                } else {
                    this.showStatus('fileStatus', 'âŒ ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼ï¼\næ”¯æŒ: .xlsx, .xls, .csv', 'error');
                }
            } catch (error) {
                console.error('âŒ æ–‡ä»¶å¤„ç†å¤±è´¥:', error);
                this.showStatus('fileStatus', `âŒ æ–‡ä»¶å¤„ç†å¤±è´¥: ${error.message}`, 'error');
            }
        }

        async handleCSVFile(file) {
            try {
                console.log('ğŸ“„ å¼€å§‹å¤„ç†CSVæ–‡ä»¶ï¼Œå°è¯•å¤šç§ç¼–ç ...');
                
                // å°è¯•å¤šç§ç¼–ç 
                const encodings = ['UTF-8', 'GBK', 'GB2312', 'GB18030'];
                let text = null;
                let usedEncoding = 'UTF-8';
                
                for (const encoding of encodings) {
                    try {
                        console.log(`ğŸ” å°è¯• ${encoding} ç¼–ç ...`);
                        text = await this.readFileAsTextWithEncoding(file, encoding);
                        
                        // ç®€å•çš„ä¹±ç æ£€æµ‹
                        if (text && !this.hasGarbledText(text)) {
                            usedEncoding = encoding;
                            console.log(`âœ… ${encoding} ç¼–ç æˆåŠŸ`);
                            break;
                        }
                    } catch (error) {
                        console.log(`âŒ ${encoding} ç¼–ç å¤±è´¥:`, error.message);
                    }
                }
                
                if (!text) {
                    // æœ€åå°è¯•æµè§ˆå™¨è‡ªåŠ¨æ£€æµ‹
                    console.log('ğŸ” å°è¯•æµè§ˆå™¨è‡ªåŠ¨æ£€æµ‹ç¼–ç ...');
                    text = await this.readFileAsText(file);
                    usedEncoding = 'è‡ªåŠ¨æ£€æµ‹';
                }
                
                if (!text) {
                    throw new Error('æ— æ³•è¯»å–æ–‡ä»¶å†…å®¹');
                }
                
                console.log(`ğŸ“„ ä½¿ç”¨ ${usedEncoding} ç¼–ç è¯»å–æˆåŠŸï¼Œå†…å®¹é•¿åº¦:`, text.length);
                this.parseCSVData(text, file.name);
                
            } catch (error) {
                throw new Error(`CSVè¯»å–å¤±è´¥: ${error.message}`);
            }
        }

        async handleExcelFile(file) {
            try {
                if (typeof XLSX === 'undefined') {
                    throw new Error('Excelå¤„ç†åº“æœªåŠ è½½');
                }

                const arrayBuffer = await this.readFileAsArrayBuffer(file);
                console.log('ğŸ“Š Excelæ–‡ä»¶è¯»å–æˆåŠŸï¼Œå¤§å°:', arrayBuffer.byteLength);
                
                const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                console.log('ğŸ“Š å·¥ä½œè¡¨:', workbook.SheetNames);
                
                if (!workbook.SheetNames.length) {
                    throw new Error('Excelæ–‡ä»¶ä¸­æ²¡æœ‰å·¥ä½œè¡¨');
                }

                const sheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[sheetName];
                const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
                
                if (jsonData.length < 2) {
                    throw new Error('Excelæ–‡ä»¶ä¸­æ²¡æœ‰è¶³å¤Ÿçš„æ•°æ®');
                }

                // å¤„ç†æ•°æ®
                const headers = jsonData[0].filter(h => h && h.toString().trim());
                const dataRows = jsonData.slice(1).filter(row => 
                    row.some(cell => cell && cell.toString().trim())
                );

                this.excelData = dataRows.map(row => {
                    const obj = {};
                    headers.forEach((header, index) => {
                        obj[header] = row[index] ? row[index].toString() : '';
                    });
                    return obj;
                });

                this.availableColumns = headers;
                
                this.showStatus('fileStatus', 
                    `âœ… Excelæ–‡ä»¶å¤„ç†æˆåŠŸï¼\næ–‡ä»¶: ${file.name}\næ•°æ®: ${this.excelData.length} è¡Œï¼Œ${headers.length} åˆ—`, 
                    'success'
                );
                
                // æ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯
                this.showFileInfo(file);
                this.buildColumnSelector();
                this.showDataStats();
                this.displayPreview();

            } catch (error) {
                throw new Error(`Excelå¤„ç†å¤±è´¥: ${error.message}`);
            }
        }

        parseCSVData(text, filename) {
            try {
                // ç®€å•çš„CSVè§£æ
                const lines = text.split('\n').filter(line => line.trim());
                
                if (lines.length < 2) {
                    throw new Error('CSVæ–‡ä»¶å†…å®¹ä¸è¶³');
                }

                const headers = this.parseCSVLine(lines[0]);
                console.log('ğŸ“„ CSVæ ‡é¢˜:', headers);

                this.excelData = [];
                for (let i = 1; i < lines.length; i++) {
                    if (lines[i].trim()) {
                        const values = this.parseCSVLine(lines[i]);
                        const row = {};
                        headers.forEach((header, index) => {
                            row[header] = values[index] || '';
                        });
                        this.excelData.push(row);
                    }
                }

                this.availableColumns = headers;
                
                this.showStatus('fileStatus', 
                    `âœ… CSVæ–‡ä»¶å¤„ç†æˆåŠŸï¼\næ–‡ä»¶: ${filename}\næ•°æ®: ${this.excelData.length} è¡Œï¼Œ${headers.length} åˆ—`, 
                    'success'
                );
                
                // æ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯ï¼ˆæ¨¡æ‹Ÿæ–‡ä»¶å¯¹è±¡ï¼‰
                const mockFile = { name: filename, size: text.length, type: 'text/csv' };
                this.showFileInfo(mockFile);
                this.buildColumnSelector();
                this.showDataStats();
                this.displayPreview();

            } catch (error) {
                throw new Error(`CSVè§£æå¤±è´¥: ${error.message}`);
            }
        }

        parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            return result;
        }

        showFileInfo(file) {
            const fileInfo = document.getElementById('fileInfo');
            const fileDetails = document.getElementById('fileDetails');
            
            if (fileInfo && fileDetails) {
                const sizeKB = (file.size / 1024).toFixed(2);
                fileDetails.innerHTML = `
                    <div style="margin-top: 8px;">
                        <strong>æ–‡ä»¶åï¼š</strong>${file.name}<br>
                        <strong>æ–‡ä»¶å¤§å°ï¼š</strong>${sizeKB} KB<br>
                        <strong>æ–‡ä»¶ç±»å‹ï¼š</strong>${file.type || 'æœªçŸ¥'}
                    </div>
                `;
                fileInfo.style.display = 'block';
            }
        }

        buildColumnSelector() {
            const columnSelector = document.getElementById('columnSelector');
            if (!columnSelector || !this.availableColumns.length) return;

            let html = `
                <h3>ğŸ¯ é€‰æ‹©è¦ç­›é€‰çš„åˆ— <span id="selectedCount">0</span> / ${this.availableColumns.length}</h3>
                <div style="margin-bottom: 15px;">
                    <button onclick="window.excelManager.selectAllColumns()" class="button">å…¨é€‰</button>
                    <button onclick="window.excelManager.clearAllColumns()" class="button secondary">æ¸…ç©º</button>
                </div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
            `;

            this.availableColumns.forEach(column => {
                html += `
                    <label style="display: flex; align-items: center; gap: 8px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                        <input type="checkbox" value="${column}" onchange="window.excelManager.toggleColumn('${column}')">
                        <span>ğŸ“„ ${column}</span>
                    </label>
                `;
            });

            html += '</div>';
            columnSelector.innerHTML = html;
            columnSelector.style.display = 'block';
        }

        toggleColumn(column) {
            if (this.selectedColumns.includes(column)) {
                this.selectedColumns = this.selectedColumns.filter(col => col !== column);
            } else {
                this.selectedColumns.push(column);
            }
            this.updateSelectedCount();
            this.updateButtons();
        }

        selectAllColumns() {
            this.selectedColumns = [...this.availableColumns];
            this.updateCheckboxes();
            this.updateSelectedCount();
            this.updateButtons();
        }

        clearAllColumns() {
            this.selectedColumns = [];
            this.updateCheckboxes();
            this.updateSelectedCount();
            this.updateButtons();
        }

        updateCheckboxes() {
            const checkboxes = document.querySelectorAll('#columnSelector input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = this.selectedColumns.includes(checkbox.value);
            });
        }

        updateSelectedCount() {
            const countElement = document.getElementById('selectedCount');
            if (countElement) {
                countElement.textContent = this.selectedColumns.length;
            }
        }

        updateButtons() {
            const filterBtn = document.getElementById('filterBtn');
            const exportCSVBtn = document.getElementById('exportCSVBtn');
            const exportExcelBtn = document.getElementById('exportExcelBtn');
            const clearFilterBtn = document.getElementById('clearFilterBtn');
            const cityInput = document.getElementById('cityInput');

            const hasData = this.excelData.length > 0;
            const hasSelectedColumns = this.selectedColumns.length > 0;

            if (filterBtn) {
                filterBtn.disabled = !hasData || !hasSelectedColumns;
            }
            if (exportCSVBtn) {
                exportCSVBtn.disabled = !hasData || !hasSelectedColumns;
            }
            if (exportExcelBtn) {
                exportExcelBtn.disabled = !hasData || !hasSelectedColumns;
            }
            if (clearFilterBtn) {
                clearFilterBtn.disabled = !hasData;
            }
            if (cityInput) {
                cityInput.disabled = !hasData || !hasSelectedColumns;
                
                if (hasSelectedColumns) {
                    cityInput.placeholder = `åœ¨æ‰€é€‰ ${this.selectedColumns.length} åˆ—ä¸­æœç´¢ï¼ˆæ”¯æŒä¸­è‹±æ–‡é€—å·åˆ†éš”ï¼‰...`;
                } else {
                    cityInput.placeholder = 'è¯·å…ˆé€‰æ‹©è¦ç­›é€‰çš„åˆ—';
                }
            }
        }

        showDataStats() {
            const dataStats = document.getElementById('dataStats');
            const totalRows = document.getElementById('totalRows');
            const totalColumns = document.getElementById('totalColumns');
            const cityColumn = document.getElementById('cityColumn');
            
            if (totalRows) totalRows.textContent = this.excelData.length;
            if (totalColumns) totalColumns.textContent = this.availableColumns.length;
            if (cityColumn) cityColumn.textContent = this.selectedColumns.length || '-';
            if (dataStats) dataStats.style.display = 'block';
        }

        displayPreview() {
            const results = document.getElementById('results');
            const dataPreview = document.getElementById('dataPreview');
            
            if (!results || !dataPreview || !this.excelData.length) return;

            const previewData = this.filteredData.length > 0 ? this.filteredData : this.excelData;
            const displayData = previewData.slice(0, 5);
            
            let html = '<div class="table-container"><table class="table"><thead><tr>';
            
            this.availableColumns.forEach(header => {
                const isSelected = this.selectedColumns.includes(header);
                const style = isSelected ? 'background: #FF9800; color: white;' : 'background: #ccc;';
                html += `<th style="${style}">${header}</th>`;
            });
            html += '</tr></thead><tbody>';
            
            displayData.forEach(row => {
                html += '<tr>';
                this.availableColumns.forEach(header => {
                    const value = row[header] || '';
                    const isSelected = this.selectedColumns.includes(header);
                    const style = isSelected ? 'background: #fff3e0; font-weight: bold;' : 'background: #f5f5f5;';
                    html += `<td style="${style}" title="${value}">${value.length > 50 ? value.substring(0, 47) + '...' : value}</td>`;
                });
                html += '</tr>';
            });
            
            html += '</tbody></table></div>';
            html += `<div style="margin-top: 10px; padding: 10px; background: #e3f2fd; border-radius: 5px;">
                ğŸ“‹ æ˜¾ç¤ºå‰ ${displayData.length} è¡Œæ•°æ®ï¼Œå…± ${previewData.length} è¡Œ
            </div>`;
            
            dataPreview.innerHTML = html;
            results.style.display = 'block';
        }

        handleFilter() {
            const cityInput = document.getElementById('cityInput');
            const searchValue = cityInput ? cityInput.value.trim() : '';
            
            if (!searchValue) {
                this.showStatus('filterStatus', 'è¯·è¾“å…¥è¦ç­›é€‰çš„å€¼ï¼', 'error');
                return;
            }
            
            if (!this.selectedColumns.length) {
                this.showStatus('filterStatus', 'è¯·å…ˆé€‰æ‹©è¦ç­›é€‰çš„åˆ—ï¼', 'error');
                return;
            }
            
            // è·å–åŒ¹é…æ¨¡å¼
            const matchModeRadio = document.querySelector('input[name="matchMode"]:checked');
            const matchMode = matchModeRadio ? matchModeRadio.value : 'exact';
            
            // è·å–æ˜¯å¦å¯ç”¨å¤šé¡¹æœç´¢
            const multiSearchCheckbox = document.getElementById('multiSearch');
            const isMultiSearch = multiSearchCheckbox ? multiSearchCheckbox.checked : false;
            
            // è·å–é€»è¾‘æ¨¡å¼
            const logicModeRadio = document.querySelector('input[name="logicMode"]:checked');
            const logicMode = logicModeRadio ? logicModeRadio.value : 'or';
            
            // å¤„ç†æœç´¢è¯ - æ”¯æŒä¸­è‹±æ–‡é€—å·
            let searchTerms = [];
            if (isMultiSearch) {
                // å¤šé¡¹æœç´¢ï¼šæ”¯æŒä¸­æ–‡é€—å·ï¼ˆï¼Œï¼‰å’Œè‹±æ–‡é€—å·ï¼ˆ,ï¼‰
                searchTerms = searchValue
                    .split(/[,ï¼Œ]/)  // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒæ—¶åŒ¹é…ä¸­è‹±æ–‡é€—å·
                    .map(term => term.trim())
                    .filter(term => term.length > 0);
                
                if (searchTerms.length === 0) {
                    this.showStatus('filterStatus', 'è¯·è¾“å…¥æœ‰æ•ˆçš„æœç´¢è¯ï¼', 'error');
                    return;
                }
                
                console.log('ğŸ” æ£€æµ‹åˆ°çš„æœç´¢è¯:', searchTerms);
            } else {
                // å•é¡¹æœç´¢
                searchTerms = [searchValue];
            }
            
            console.log('ğŸ” æœç´¢å‚æ•°:', { matchMode, isMultiSearch, searchTerms, logicMode });
            
            // æ‰§è¡Œç­›é€‰
            this.filteredData = this.excelData.filter(row => {
                return this.selectedColumns.some(column => {
                    const cellValue = row[column];
                    if (!cellValue) return false;
                    
                    const cellStr = cellValue.toString();
                    
                    // æ£€æŸ¥æ˜¯å¦åŒ¹é…ä»»æ„ä¸€ä¸ªæœç´¢è¯
                    return searchTerms.some(searchTerm => {
                        return this.matchValue(cellStr, searchTerm, matchMode);
                    });
                });
            });
            
            // æ ¹æ®é€»è¾‘æ¨¡å¼è¿›ä¸€æ­¥ç­›é€‰
            if (logicMode === 'and' && this.filteredData.length > 0) {
                this.filteredData = this.filteredData.filter(row => {
                    return searchTerms.every(searchTerm => {
                        return this.selectedColumns.some(column => {
                            const cellValue = row[column];
                            return cellValue && this.matchValue(cellValue.toString(), searchTerm, matchMode);
                        });
                    });
                });
            }
            
            // æ˜¾ç¤ºç»“æœ
            if (this.filteredData.length > 0) {
                const modeDescriptions = {
                    'exact': 'ç²¾ç¡®åŒ¹é…ï¼ˆå®Œå…¨ç›¸ç­‰ï¼‰',
                    'exactIgnoreCase': 'ç²¾ç¡®åŒ¹é…ï¼ˆå¿½ç•¥å¤§å°å†™ï¼‰',
                    'contains': 'åŒ…å«åŒ¹é…ï¼ˆå¹¿ä¹‰æœç´¢ï¼‰',
                    'containsIgnoreCase': 'åŒ…å«åŒ¹é…ï¼ˆå¿½ç•¥å¤§å°å†™ï¼‰'
                };
                
                const searchDescription = isMultiSearch ? 
                    `å¤šé¡¹æœç´¢ï¼š${searchTerms.join('ã€')}` : 
                    `å•é¡¹æœç´¢ï¼š${searchValue}`;
                
                const logicDescription = logicMode === 'and' ? 'å¹¶ä¸”' : 'æˆ–è€…';
                
                this.showStatus('filterStatus', 
                    `ğŸ‰ ç­›é€‰å®Œæˆï¼æ‰¾åˆ° ${this.filteredData.length} æ¡æ•°æ®\n\n` +
                    `${searchDescription}\n` +
                    `åŒ¹é…æ¨¡å¼ï¼š${modeDescriptions[matchMode]}\n` +
                    `é€»è¾‘æ¨¡å¼ï¼š${logicDescription}\n` +
                    `ç­›é€‰åˆ—ï¼š${this.selectedColumns.join('ã€')}`, 
                    'success'
                );
                this.displayPreview();
            } else {
                this.showStatus('filterStatus', 
                    `ğŸ˜” æœªæ‰¾åˆ°åŒ¹é…çš„æ•°æ®ï¼\n\n` +
                    `æœç´¢è¯ï¼š${searchTerms.join('ã€')}\n` +
                    `åŒ¹é…æ¨¡å¼ï¼š${modeDescriptions[matchMode] || matchMode}\n` +
                    `å·²æœç´¢åˆ—ï¼š${this.selectedColumns.join('ã€')}`, 
                    'error'
                );
            }
        }

        // æ·»åŠ åŒ¹é…å€¼çš„æ–¹æ³•
        matchValue(cellValue, searchTerm, matchMode) {
            switch (matchMode) {
                case 'exact':
                    return cellValue.trim() === searchTerm.trim();
                case 'exactIgnoreCase':
                    return cellValue.trim().toLowerCase() === searchTerm.trim().toLowerCase();
                case 'contains':
                    return cellValue.includes(searchTerm);
                case 'containsIgnoreCase':
                    return cellValue.toLowerCase().includes(searchTerm.toLowerCase());
                default:
                    return cellValue.trim() === searchTerm.trim();
            }
        }

        clearFilter() {
            this.filteredData = [];
            const cityInput = document.getElementById('cityInput');
            if (cityInput) {
                cityInput.value = '';
                cityInput.placeholder = 'è¾“å…¥æœç´¢è¯ï¼Œå¤šä¸ªè¯ç”¨é€—å·åˆ†éš”ï¼Œå¦‚ï¼šåŒ—äº¬,ä¸Šæµ·,å¹¿å·';
            }
            this.displayPreview();
            this.showStatus('filterStatus', 'ç­›é€‰å·²æ¸…é™¤', 'info');
        }

        exportCSV() {
            if (!this.filteredData.length) {
                this.showStatus('exportStatus', 'æ²¡æœ‰å¯å¯¼å‡ºçš„æ•°æ®', 'error');
                return;
            }

            const csvRows = [];
            const headers = this.selectedColumns;
            csvRows.push(headers.join(','));

            this.filteredData.forEach(row => {
                const values = headers.map(header => {
                    const escaped = (row[header] || '').toString().replace(/"/g, '""');
                    return `"${escaped}"`;
                });
                csvRows.push(values.join(','));
            });

            const csvContent = csvRows.join('\n');
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filenameInput = document.getElementById('filenameInput');
            const filename = (filenameInput && filenameInput.value.trim()) || `export-${timestamp}`;
            const fullFilename = filename.endsWith('.csv') ? filename : `${filename}.csv`;

            this.downloadFile(fullFilename, csvContent);
            this.showStatus('exportStatus', `æ•°æ®å·²å¯¼å‡ºä¸º CSV æ–‡ä»¶ï¼š${fullFilename}`, 'success');
        }

        exportExcel() {
            if (!this.filteredData.length) {
                this.showStatus('exportStatus', 'æ²¡æœ‰å¯å¯¼å‡ºçš„æ•°æ®', 'error');
                return;
            }

            const wb = XLSX.utils.book_new();
            const wsData = [];

            // æ·»åŠ è¡¨å¤´
            wsData.push(this.selectedColumns);

            // æ·»åŠ æ•°æ®è¡Œ
            this.filteredData.forEach(row => {
                const rowData = this.selectedColumns.map(col => row[col] || '');
                wsData.push(rowData);
            });

            const ws = XLSX.utils.aoa_to_sheet(wsData);
            XLSX.utils.book_append_sheet(wb, ws, "Sheet1");

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filenameInput = document.getElementById('filenameInput');
            const filename = (filenameInput && filenameInput.value.trim()) || `export-${timestamp}`;
            const fullFilename = filename.endsWith('.xlsx') ? filename : `${filename}.xlsx`;

            XLSX.writeFile(wb, fullFilename);
            this.showStatus('exportStatus', `æ•°æ®å·²å¯¼å‡ºä¸º Excel æ–‡ä»¶ï¼š${fullFilename}`, 'success');
        }

        showStatus(elementId, message, type) {
            const statusElement = document.getElementById(elementId);
            if (!statusElement) return;

            statusElement.className = 'status ' + (type || 'info');
            statusElement.innerHTML = message;
            statusElement.style.display = 'block';

            setTimeout(() => {
                statusElement.style.display = 'none';
            }, 5000);
        }

        downloadFile(filename, content) {
            const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async readFileAsTextWithEncoding(file, encoding) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const text = e.target.result;
                    resolve(text);
                };
                reader.onerror = (e) => {
                    reject(new Error('æ–‡ä»¶è¯»å–å¤±è´¥'));
                };
                reader.readAsText(file, encoding);
            });
        }

        async readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const text = e.target.result;
                    resolve(text);
                };
                reader.onerror = (e) => {
                    reject(new Error('æ–‡ä»¶è¯»å–å¤±è´¥'));
                };
                reader.readAsText(file);
            });
        }

        async readFileAsArrayBuffer(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const arrayBuffer = e.target.result;
                    resolve(arrayBuffer);
                };
                reader.onerror = (e) => {
                    reject(new Error('æ–‡ä»¶è¯»å–å¤±è´¥'));
                };
                reader.readAsArrayBuffer(file);
            });
        }

        hasGarbledText(text) {
            // ç®€å•çš„ä¹±ç æ£€æµ‹ï¼šæ£€æŸ¥æ˜¯å¦åŒ…å«å¸¸è§çš„ä¹±ç å­—ç¬¦
            const garbledPatterns = [/[\uFFFD\u202E\u202C]/, /[\uD800-\uDFFF]/, /[\uDC00-\uDC7F]/];
            return garbledPatterns.some(pattern => pattern.test(text));
        }
    }

    // åˆ›å»ºå…¨å±€å®ä¾‹
    window.excelManager = new ExcelManager();
    </script>
</body>
</html>